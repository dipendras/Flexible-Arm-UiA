<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.9">
  <POU Name="FB_Joint" Id="{66b8c442-7a21-4eed-a901-9982c98a5f83}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_Joint
VAR_INPUT
	bReset : BOOL;
	bEnable : BOOL;//e-stop can use this
	eRobotMode : E_RobotMode;


	bPositionModeExecute : BOOL;

	
	fGearRatio : LREAL := 1000.0;
	fTorqueScaling : LREAL := 1.0;
	
	qRef : LREAL;
	qRef_t : LREAL;
	qRef_tt : LREAL;
	fShaftAdditiveTorque : LREAL; // [Nm] on shaft
	
	fShaftTorqueRef : LREAL; //Nm initialize with holding torque??
	
	fOffset : LREAL;
END_VAR
VAR_OUTPUT
	// eRobotMode : E_RobotMode;

	bActive : BOOL;
	bAxisStopped :BOOL;
	
	// Joint feedback
	q : LREAL;
	q_t : LREAL;
	tau : LREAL;
	fVelocityControllerShaftOutputTorque: LREAL; // [Nm] on shaft
END_VAR
VAR
	fAdditiveTorque : LREAL; // [Nm] on motor
	nAdditiveTorquePerc AT %Q* : INT;	
	nVelocityControllerOutputTorque AT %I*: INT;
 	fVelocityControllerOutputTorque: LREAL; // [Nm] on motor

	// Drive axis stuff
	axis : AXIS_REF;
	fbPower : MC_Power;
	fbReset : MC_Reset;
	
	//SoftStop
	fbStop : MC_Stop;	
	fDeceleration :LREAL := 100;
	fJerk :LREAL := 300;

	
	
	// External setpoint	
	fbExtSetPointGenEnable : MC_ExtSetPointGenEnable;
	fbExtSetPointGenDisable : MC_ExtSetPointGenDisable;
	fbReadParameterSet : MC_ReadParameterSet;
	stAxisParameterSet : ST_AxisParameterSet;
	bReadParameterSet : BOOL := TRUE;
	
	//move to position
	fbAxisMoveAbsolute : MC_MoveAbsolute;
	
	

	fbTorqueControl : FB_TorqueController;
	

	
		
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[fbReadParameterSet(
	Axis := axis,
	Parameter := stAxisParameterSet,
	Execute := bReadParameterSet AND NOT fbReadParameterSet.Busy
);
IF NOT(fbReadParameterSet.Busy OR fbReadParameterSet.Error) THEN
	bReadParameterSet := FALSE;
END_IF

bAxisStopped := (
	axis.Status.NotMoving  
	AND NOT axis.Status.HasJob //this is necessary to avoid error while stopping when torque control mode is on
	AND ((eRobotMode = E_RobotMode.STOP) OR (eRobotMode = E_RobotMode.ESTOP))
	AND NOT(fbExtSetPointGenEnable.Enabled)
);

// Power and reset logic
fbPower(
	Axis := axis,
	Enable := (bEnable AND NOT bAxisStopped),
	Enable_Positive := (bEnable AND NOT bAxisStopped),
	Enable_Negative := (bEnable AND NOT bAxisStopped)
);

fbReset(
	Execute := bReset AND (bAxisStopped OR (eRobotMode = E_RobotMode.ESTOP)), //brest must also be set from fbrobot 
	Axis := axis
);

//you can't execute fbstop when fbExtSetPointGenEnable.Enabled ----> motion comands are not allowed for external setpoint generated axis
fbStop(
	Axis := axis,
	Execute := NOT(fbExtSetPointGenEnable.Enabled) AND (eRobotMode = E_RobotMode.STOP),
	Deceleration := fDeceleration,
	Jerk := fJerk
);

// Read power status
bActive := fbPower.Status;

//velocity control
// Enable external setpoint when on
fbExtSetPointGenDisable(
	Axis := axis,
	Execute := (eRobotMode <> E_RobotMode.VELOCITY) OR NOT(bActive)
);

fbExtSetPointGenEnable(
	Axis := axis,
	Execute := (eRobotMode = E_RobotMode.VELOCITY) AND bActive
);

IF bActive AND fbExtSetPointGenEnable.Enabled THEN		
	//Feed extrernal setpoints to axis interface
	MC_ExtSetPointGenFeed(
		Axis := axis,
		Position := LIMIT(stAxisParameterSet.fEncSoftEndMin, fOffset - qRef, stAxisParameterSet.fEncSoftEndMax),
		Velocity := -qRef_t,
		Acceleration := -qRef_tt,
		Direction := getDirection(-qRef_t, -qRef_tt)
	);
	
	fAdditiveTorque := fShaftAdditiveTorque / fGearRatio;
	
	nAdditiveTorquePerc := TO_INT(
		RescaleRange(
			in := -fAdditiveTorque, //flip the direction
			in_min := -fTorqueScaling, 
			in_max := fTorqueScaling,
			out_min := -1000, 
			out_max := 1000 
		)
	);
	
	fVelocityControllerOutputTorque := 	RescaleRange(
		in := -TO_LREAL(nVelocityControllerOutputTorque), //flip the direction
		in_min := -1000, 
		in_max := 1000,
		out_min := -fTorqueScaling, 
		out_max := fTorqueScaling 
	);
	fVelocityControllerShaftOutputTorque :=fVelocityControllerOutputTorque*fGearRatio; 
ELSE
	nAdditiveTorquePerc := 0;
END_IF


//position control
fbAxisMoveAbsolute(
	Axis := axis,
	Execute := bPositionModeExecute AND (eRobotMode = E_RobotMode.POSITION) AND bActive,
	Position := (fOffset - qRef), // (qRef - fOffset),
	Velocity := qRef_t,
	BufferMode := MC_BufferMode.MC_Aborting
);



// Update axis data
axis();




//-----------------torque control
fbTorqueControl(
	Axis := axis,
	bEnable := bActive AND (eRobotMode = E_RobotMode.TORQUE),
	fShaftTorqueCmdNm := -fShaftTorqueRef, //negative sign is to change the direction
	fTorqueScaling := fTorqueScaling,
	fGearRatio := fGearRatio
);

// fbTorqueControl.readFeedback();



q := -axis.NcToPlc.ActPos + fOffset;
q_t := -axis.NcToPlc.ActVelo;
tau := - fbTorqueControl.fShaftTorqueFbkNm;




	
]]></ST>
    </Implementation>
    <Method Name="getDirection" Id="{14240053-4bfe-4208-8932-d2fa94688482}">
      <Declaration><![CDATA[METHOD PRIVATE getDirection : DINT
VAR_INPUT
	fTargetVelocity : LREAL;
	fTargetAcceleration : LREAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF fTargetVelocity = 0.0 AND fTargetAcceleration = 0.0 THEN
	// Standstill
	getDirection := 0;
	
ELSIF fTargetVelocity >= 0.0 THEN
	// Positive motion
	getDirection := 1;
	
ELSE
	// Negative motion
	getDirection := -1;
	
END_IF]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="FB_Joint">
      <LineId Id="2579" Count="61" />
      <LineId Id="2694" Count="1" />
      <LineId Id="2641" Count="8" />
      <LineId Id="2698" Count="0" />
      <LineId Id="2700" Count="0" />
      <LineId Id="2702" Count="5" />
      <LineId Id="2710" Count="0" />
      <LineId Id="2650" Count="42" />
      <LineId Id="76" Count="0" />
    </LineIds>
    <LineIds Name="FB_Joint.getDirection">
      <LineId Id="6" Count="11" />
      <LineId Id="5" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>