<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.9">
  <POU Name="FB_Robot3R" Id="{ac314762-16df-47a2-b7b8-44cc8c775bfa}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_Robot3R
VAR_INPUT
	bEmStop : BOOL;
	Ts : LREAL := 0.01;
	bReset : BOOL;
	bEnable : BOOL;
	bEnableJoint : ARRAY [0..2] OF BOOL;
	eRobotModeCmd : E_RobotMode;
	fVelInput : ARRAY [0..2] OF LREAL;
	fPosInput : ARRAY [0..2] OF LREAL;	
	fShaftAdditiveTorque : ARRAY [0..2] OF LREAL; // [Nm]
	fShaftAdditiveVelocity : ARRAY [0..2] OF LREAL; // [deg/sec]
	bPositionModeExecute 	: BOOL;
	bAddDeflection : BOOL := FALSE;
	fDeflection : ARRAY [0..2] OF LREAL := [0.0,0.0,0.0];
	fDeflectionGain : ARRAY [0..2] OF LREAL := [0.0, 0.0,0.0];
//	fJointPositionOffset 	: ARRAY [0..2] OF LREAL;	
//	fJointCalibrationOffset : ARRAY [0..2] OF LREAL;
//	fJointLimitMin : ARRAY [0..2] OF LREAL;	
//	fJointLimitMax : ARRAY [0..2] OF LREAL;
	stJointParams : ARRAY [0..2] OF ST_JointParameters;
		fPosThreshold : LREAL := 0.005;
END_VAR
VAR_OUTPUT
	eRobotMode : E_RobotMode := E_RobotMode.STOP;
	
	fPosDiff : ARRAY [0..2] OF LREAL;
	fDeflectionCompensation : ARRAY [0..2] OF LREAL;
	
	// Robot feedback
	q : ARRAY [0..2] OF LREAL;
	q_t : ARRAY [0..2] OF LREAL;	
	tau : ARRAY [0..2] OF LREAL;
	//the following two lines is added to remove the joint acc from imu readings
	q_t_old : ARRAY [0..2] OF LREAL := [0.0, 0.0, 0.0];
	q_tt : ARRAY [0..2] OF LREAL;
	
	bAnyJointActive : BOOL;
END_VAR
VAR
	// Setpoints
	qRef : ARRAY [0..2] OF LREAL;
	qRef_t : ARRAY [0..2] OF LREAL;
	qRef_tt : ARRAY [0..2] OF LREAL;
	
	fLimitedPosInput : ARRAY [0..2] OF LREAL;
	
	fShaftTorqueRef : ARRAY [0..2] OF LREAL;

	i : USINT;
	j : USINT;
	k : USINT;
	joints : ARRAY [0..2] OF FB_Joint;
		
	//Velcity of last timestamp
	fVelInputOld : ARRAY [0..2] OF LREAL;
	
	
	//Torque oontrol
	Kp : ARRAY [0..2] OF LREAL := [20, 20, 20];
	Kd : ARRAY [0..2] OF LREAL := [5, 5, 5];
	fGravityTorque : ARRAY [0..2] OF LREAL := [0.0, 0.0, 0.0];//shouldnot be zero
	fbPid : FB_CTRL_PID;
	stPidParams : ST_CTRL_PID_PARAMS;
	ePidMode : E_CTRL_MODE;
	bInitPidControl : BOOL := TRUE;
	
	//filters for velocity feeback
	fbJointVelFilters : ARRAY [0..2] OF FB_LowPassFilter;
	fJointVelFilterCutoff : ARRAY [0..2] OF LREAL := [ 10.0, 10.0, 10.0 ];
	q_t_Filtered : ARRAY [0..2] OF LREAL;
	stJointVelFilterParams : ST_FilterParams;
	bFirstRun : BOOL := TRUE;
	

	//trajectory generation
	fbTrajectoryGenerator : ARRAY [0..2] OF FB_TrajectoryGenerator;
	ft : ARRAY [0..2] OF LREAL := [0.0,0.0,0.0];
	ftf : LREAL := 5.0;
	fPosInputOld : ARRAY [0..2] OF LREAL;	
	bExecuteReady : ARRAY [0..2] OF BOOL := [FALSE, FALSE, FALSE];	
	
	
	
	
	//PD control in position loop
		//Torque oontrol
	KpPos : ARRAY [0..2] OF LREAL := [0.2, 0.2, 0.2];
	KdPos : ARRAY [0..2] OF LREAL := [0.0, 0.0, 0.0];
	KffPos : ARRAY [0..2] OF LREAL := [1, 1, 1];
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[IF bEmStop AND (eRobotMode <> E_RobotMode.ESTOP) THEN
	eRobotModeCmd := E_RobotMode.ESTOP;
END_IF

IF eRobotModeCmd <> E_RobotMode.NONE THEN
	CASE eRobotModeCmd OF
		 E_RobotMode.STOP:
		 	
			
		 	eRobotMode := E_RobotMode.STOP;
			
		 E_RobotMode.ESTOP:
		 	eRobotMode := E_RobotMode.ESTOP;
		 
		 E_RobotMode.POSITION:
				
		 	eRobotMode := E_RobotMode.POSITION;
		 
		 E_RobotMode.VELOCITY:
		 	
		 	eRobotMode := E_RobotMode.VELOCITY;
			
		E_RobotMode.TORQUE:
			eRobotMode := E_RobotMode.TORQUE;
			
	END_CASE	
END_IF
eRobotModeCmd := E_RobotMode.NONE;

IF bReset AND NOT(bEmStop)  THEN
	eRobotMode := E_RobotMode.STOP;
END_IF

// E-stop mode
IF(eRobotMode = E_RobotMode.ESTOP) THEN
	bEnable := FALSE;
	bReset := TRUE;	//to avoid error: the axis loss the enable signal while doing something
END_IF


bAnyJointActive := joints[0].bActive;
FOR k:= 1 TO 2 DO
	bAnyJointActive := bAnyJointActive OR joints[k].bActive;	
END_FOR

IF(eRobotMode = E_RobotMode.STOP) AND  NOT bAnyJointActive THEN
	bEnable := FALSE;
END_IF

FOR i := 0 TO 2 DO
	fLimitedPosInput[i] := LIMIT(
		stJointParams[i].stPositionLimits.fMin,
		fPosInput[i],
		stJointParams[i].stPositionLimits.fMax
	);	
END_FOR

// position mode
IF(eRobotMode = E_RobotMode.POSITION) THEN
	positionMode();
// velocity mode
ELSIF(eRobotMode = E_RobotMode.VELOCITY) THEN
	velocityMode();
ELSIF(eRobotMode = E_RobotMode.TORQUE) THEN
//	torqueMode(); //calculate ref torque in all modes???
END_IF

torqueMode(); //update referece torque all the time so that we don't receive too high command in the start


// Execute joints
FOR j:= 0 TO 2 DO
	joints[j](
		bReset:=bReset,
		bEnable:=bEnable AND bEnableJoint[j],
		eRobotMode := eRobotMode,
		bPositionModeExecute := bPositionModeExecute,
		fGearRatio := CONSTANTS.GEAR_RATIO[j],
		fTorqueScaling := CONSTANTS.TORQUE_SCALING[j],
		qRef:=qRef[j],
		qRef_t := qRef_t[j],
		qRef_tt:=qRef_tt[j],
		fShaftAdditiveTorque := fShaftAdditiveTorque[j],
		fShaftAdditiveVelocity := fShaftAdditiveVelocity[j],
		fShaftTorqueRef  :=  fShaftTorqueRef[j],
//		fOffset := stJointParams[j].stOffsets.fCalibrationOffset + stJointParams[j].stOffsets.fPositionOffset, // fJointPositionOffset[j] + fJointCalibrationOffset[j],
		stJointParams := stJointParams[j],
		Ts := Ts
	);

	// Assign feedback data from joints
	q[j] := joints[j].q;
	q_t[j] := joints[j].q_t;
	tau[j] := joints[j].tau;
	
	q_tt[j] := (q_t[j] - q_t_old[j])/Ts;
	q_t_old[j] := q_t[j];
		
END_FOR


]]></ST>
    </Implementation>
    <Method Name="positionMode" Id="{f9d459a6-0feb-4986-b627-22787cb88f98}">
      <Declaration><![CDATA[METHOD PRIVATE positionMode : BOOL
VAR_INPUT
	
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
FOR i:= 0 TO 2 DO
	IF joints[i].bActive THEN		
		// Set input based on velocity input u
		qRef[i] := fPosInput[i];
		qRef_t[i] := fVelInput[i];
		
	END_IF
	
END_FOR]]></ST>
      </Implementation>
    </Method>
    <Method Name="torqueMode" Id="{917d5002-9927-47e3-af29-77ce3af9dfae}">
      <Declaration><![CDATA[METHOD PRIVATE torqueMode : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF bInitPidControl THEN
	stPidParams.tCtrlCycleTime := T#10MS;
	stPidParams.tTaskCycleTime := T#10MS;
	stPidParams.fKp := 0.1;
	stPidParams.tTn                    := T#1000MS; 
	stPidParams.tTv                    := T#100MS; 
	stPidParams.tTd                    := T#100MS; 
	stPidParams.fOutMaxLimit           := 20; //Nm
	stPidParams.fOutMinLimit           := -20; //NM
	stPidParams.bPInTheFeedbackPath    := FALSE;
	stPidParams.bDInTheFeedbackPath    := TRUE;
	stPidParams.bARWOnIPartOnly        := FALSE;
	
	ePidMode := eCTRL_MODE_ACTIVE; 
	bInitPidControl := FALSE;
END_IF


fbPid(fSetpointValue := fPosInput[2],
		fActualValue := joints[2].q,
		eMode := ePidMode,
		stParams := stPidParams);


IF bFirstRun THEN
	bFirstRun := FALSE;
	FOR i := 0 TO 2 DO
		
		//initialize JointVel Filters
		stJointVelFilterParams.fCutoff := fJointVelFilterCutoff[i];
		stJointVelFilterParams.fDeltaTime := Ts;
		stJointVelFilterParams.fInitialValue := 0.0;
		fbJointVelFilters[i].init(stParams := stJointVelFilterParams);
		
	END_FOR
END_IF		
		
		
fGravityTorque[2] := (RobotParams.fLinkMass[2]/2.0 + RobotParams.fPayloadMass)*RobotParams.fGravity*RobotParams.fLinkLength[2]*COS((joints[0].q + joints[1].q + joints[2].q)*CONSTANTS.DEG_TO_RAD);



FOR i:= 0 TO 2 DO
//	IF joints[i].bActive THEN		
		// get input position from HMI		
		//calculate gravity torque
		
//		fShaftTorqueRef[i] :=  fbPid.fOut;
		fbJointVelFilters[i].update(joints[i].q_t);
		q_t_Filtered[i] := fbJointVelFilters[i].fOut;
		fShaftTorqueRef[i] := fShaftAdditiveTorque[i] + Kp[i]*(fPosInput[i] - joints[i].q)* CONSTANTS.DEG_TO_RAD + Kd[i]*(0.0 - q_t_Filtered[i])*CONSTANTS.DEG_TO_RAD + fGravityTorque[i]; //add gravity torque here 
		
//	END_IF	
END_FOR]]></ST>
      </Implementation>
    </Method>
    <Method Name="velocityMode" Id="{125ad195-c68c-497a-bc79-95830c09961a}">
      <Declaration><![CDATA[METHOD PRIVATE velocityMode : BOOL
VAR_INPUT
END_VAR
VAR
	
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Integrate position

FOR i:= 0 TO 2 DO
	IF bAddDeflection THEN
		fDeflectionCompensation[i] :=  fDeflectionGain[i] *fDeflection[i];
	ELSE			
		fDeflectionCompensation[i] := 0.0;
	END_IF
	
//	qRef[i] := joints[i].q;
	IF joints[i].bActive THEN	
///	
		// Set input based on velocity input u
//		qRef[i] := qRef[i] + fVelInput[i]*Ts;
//		qRef_t[i] := fVelInput[i];
//		qRef_tt[i] := (fVelInput[i]-fVelInputOld[i])/(Ts);
//		// Update old variable
//		fVelInputOld[i] := fVelInput[i];
		
///	
//-----------------------------------------------------------------------------------------------------------------------------------------		
			//traj
			//check if the pos input is changed
			IF bPositionModeExecute AND (NOT bExecuteReady[i]) THEN
				ft[i] := 0.0;
				fbTrajectoryGenerator[i].init(fqStartInit := joints[i].q + fDeflectionCompensation[i], fqFinalInit := fLimitedPosInput[i], ftFinalInit := ftf);
				bExecuteReady[i] := TRUE;
			END_IF
			IF bExecuteReady[i] THEN
				fbTrajectoryGenerator[i].getTrajectory(ftTraj := ft[i]);
				
//				qRef[i] := fbTrajectoryGenerator[i].fqPos;
//				qRef_t[i]:= fbTrajectoryGenerator[i].fqVel;
//				qRef_tt[i] :=  fbTrajectoryGenerator[i].fqAcc;
//-------------------------------------------------------------------------------------------------------------
				fPosDiff[i] := fbTrajectoryGenerator[i].fqPos - fDeflectionCompensation[i] - joints[i].q;
				qRef[i] := fbTrajectoryGenerator[i].fqPos - fDeflectionCompensation[i]; // joints[i].q + qRef_t[i]*Ts;	
				qRef_t[i] := KffPos[i]*fbTrajectoryGenerator[i].fqVel + KpPos[i]*fPosDiff[i] + KdPos[i]*(0.0 - q_t_Filtered[i]);
				qRef_tt[i] := fbTrajectoryGenerator[i].fqAcc;		
//------------------------------------------------------------------------------------------------------------------------------------	 
				ft[i] := ft[i]+Ts;
			ELSE
				qRef[i] := joints[i].q;
				qRef_t[i]:= 0.0;
				qRef_tt[i] :=  0.0;
				ft[i] := 0.0;
			END_IF
			
			IF (ft[i] > ftf) AND (ABS(fPosDiff[i]) < fPosThreshold) AND NOT bPositionModeExecute THEN //(ft[i] > ftf) remove
				bExecuteReady[i] := FALSE;
				ft[i] := 0.0;
			END_IF

//-----------------------------------------------------------------------------------------------------------------------------------------

////PD Control in position---------------------------------------------------------------------
		
//		qRef[i] := joints[i].q + qRef_t[i]*Ts;;
//		qRef_t[i] := KpPos[i]*(fPosInput[i] - joints[i].q) + KdPos[i]*(0.0 - q_t_Filtered[i]);
//		qRef_tt[i] :=  (qRef_t[i]-fVelInputOld[i])/(Ts);		
//		fVelInputOld[i] := qRef_t[i];

////--------------------------------------------------------------------------------------		
	ELSE
		bExecuteReady[i] := FALSE;
		fbTrajectoryGenerator[i].init(fqStartInit := joints[i].q, fqFinalInit := fLimitedPosInput[i], ftFinalInit := ftf);
		qRef[i] := joints[i].q;
		qRef_t[i]:= 0.0;
		qRef_tt[i] :=  0.0;	
	END_IF
	
END_FOR]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="FB_Robot3R">
      <LineId Id="983" Count="6" />
      <LineId Id="1137" Count="0" />
      <LineId Id="1139" Count="0" />
      <LineId Id="993" Count="2" />
      <LineId Id="999" Count="2" />
      <LineId Id="1131" Count="0" />
      <LineId Id="1004" Count="2" />
      <LineId Id="1132" Count="0" />
      <LineId Id="1010" Count="2" />
      <LineId Id="1015" Count="1" />
      <LineId Id="1018" Count="4" />
      <LineId Id="1024" Count="8" />
      <LineId Id="1034" Count="4" />
      <LineId Id="1077" Count="0" />
      <LineId Id="1039" Count="0" />
      <LineId Id="1041" Count="0" />
      <LineId Id="1043" Count="0" />
      <LineId Id="1420" Count="1" />
      <LineId Id="1424" Count="2" />
      <LineId Id="1428" Count="1" />
      <LineId Id="1423" Count="0" />
      <LineId Id="1044" Count="6" />
      <LineId Id="1123" Count="1" />
      <LineId Id="1051" Count="9" />
      <LineId Id="1080" Count="0" />
      <LineId Id="1061" Count="1" />
      <LineId Id="1140" Count="0" />
      <LineId Id="1063" Count="2" />
      <LineId Id="1192" Count="0" />
      <LineId Id="1262" Count="0" />
      <LineId Id="1121" Count="0" />
      <LineId Id="1066" Count="0" />
      <LineId Id="1414" Count="0" />
      <LineId Id="1332" Count="0" />
      <LineId Id="1067" Count="5" />
      <LineId Id="1525" Count="0" />
      <LineId Id="1524" Count="0" />
      <LineId Id="1526" Count="0" />
      <LineId Id="1523" Count="0" />
      <LineId Id="1074" Count="2" />
      <LineId Id="42" Count="0" />
    </LineIds>
    <LineIds Name="FB_Robot3R.positionMode">
      <LineId Id="7" Count="1" />
      <LineId Id="10" Count="3" />
      <LineId Id="23" Count="0" />
      <LineId Id="21" Count="1" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_Robot3R.torqueMode">
      <LineId Id="49" Count="0" />
      <LineId Id="53" Count="9" />
      <LineId Id="52" Count="0" />
      <LineId Id="63" Count="2" />
      <LineId Id="51" Count="0" />
      <LineId Id="36" Count="0" />
      <LineId Id="31" Count="1" />
      <LineId Id="46" Count="0" />
      <LineId Id="48" Count="0" />
      <LineId Id="47" Count="0" />
      <LineId Id="33" Count="0" />
      <LineId Id="71" Count="3" />
      <LineId Id="80" Count="7" />
      <LineId Id="69" Count="0" />
      <LineId Id="16" Count="0" />
      <LineId Id="70" Count="0" />
      <LineId Id="17" Count="0" />
      <LineId Id="45" Count="0" />
      <LineId Id="27" Count="0" />
      <LineId Id="26" Count="0" />
      <LineId Id="6" Count="2" />
      <LineId Id="24" Count="1" />
      <LineId Id="23" Count="0" />
      <LineId Id="21" Count="0" />
      <LineId Id="88" Count="0" />
      <LineId Id="14" Count="0" />
      <LineId Id="11" Count="1" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_Robot3R.velocityMode">
      <LineId Id="9" Count="2" />
      <LineId Id="130" Count="1" />
      <LineId Id="137" Count="0" />
      <LineId Id="139" Count="0" />
      <LineId Id="132" Count="0" />
      <LineId Id="129" Count="0" />
      <LineId Id="12" Count="1" />
      <LineId Id="56" Count="0" />
      <LineId Id="14" Count="4" />
      <LineId Id="57" Count="1" />
      <LineId Id="25" Count="0" />
      <LineId Id="59" Count="9" />
      <LineId Id="118" Count="0" />
      <LineId Id="69" Count="2" />
      <LineId Id="116" Count="0" />
      <LineId Id="124" Count="0" />
      <LineId Id="115" Count="0" />
      <LineId Id="113" Count="1" />
      <LineId Id="117" Count="0" />
      <LineId Id="73" Count="0" />
      <LineId Id="81" Count="0" />
      <LineId Id="84" Count="1" />
      <LineId Id="83" Count="0" />
      <LineId Id="82" Count="0" />
      <LineId Id="74" Count="0" />
      <LineId Id="80" Count="0" />
      <LineId Id="75" Count="1" />
      <LineId Id="89" Count="0" />
      <LineId Id="77" Count="0" />
      <LineId Id="100" Count="0" />
      <LineId Id="102" Count="4" />
      <LineId Id="79" Count="0" />
      <LineId Id="107" Count="0" />
      <LineId Id="52" Count="0" />
      <LineId Id="110" Count="1" />
      <LineId Id="44" Count="0" />
      <LineId Id="96" Count="0" />
      <LineId Id="120" Count="0" />
      <LineId Id="94" Count="1" />
      <LineId Id="93" Count="0" />
      <LineId Id="30" Count="0" />
      <LineId Id="19" Count="0" />
      <LineId Id="21" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>